package medium.leetcode390;

/**
 * 消除游戏:
 * 给定一个从1 到 n 排序的整数列表。
 * 首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。
 * 第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。
 * 我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
 * 返回长度为 n 的列表中，最后剩下的数字。
 *
 * 示例：
 * 输入:
 * n = 9,
 * 1 2 3 4 5 6 7 8 9
 * 2 4 6 8
 * 2 6
 * 6
 * 输出:
 * 6
 */
public class Solution {

    /**
     * 参考：https://leetcode-cn.com/problems/elimination-game/solution/gui-lu-de-xun-zhao-by-luo-ben-zhu-xiao-man-tou/
     * 找规律：
     * 找出在消除数字的过程中第一个数字的变化规律
     *
     * 假设n 为奇数，如 n = 5
     * 则初始数字序列为： 1， 2， 3， 4， 5
     * 如果从左边开始消，删除后，序列为： 2， 4， 5
     *      第一个数字就是删除前的第一个数字的后一个数字，即2
     * 如果从右边开始消，删除后，序列为： 2， 4
     *      第一个数字就是删除前的第一个数字的后一个数字，即2
     *
     * 假设n 为偶数，如 n = 4
     * 则初始数字序列为： 1， 2， 3， 4
     * 如果从左边开始消，删除后，序列为： 2， 4
     *      第一个数字就是删除前的第一个数字的后一个数字，即2
     * 如果从右边开始消，删除后，序列为： 1， 3
     *      第一个数字就是删除前的第一个数字，即1
     *
     * 根据n为偶数还是奇数，得出第一个数字的规律：
     *  n       偶数   奇数
     *  左边    2       2
     *  右边    2       1
     *
     * 而数字序列：1， 2， 3， 4， 5或 1， 2， 3， 4又是等差数列，一开始公差为1，每消除n的一半数字，公差加倍，可以根据公差得出删除后第一个数字的值
     */
    public int lastRemaining(int n) {
        if(n < 0) return 0;
        int first = 1;//序列的第一个数
        int d = 1;//公差
        boolean isOdd = (n & 1) == 1;
        boolean isLeft = true;
        while(n > 1){
            if(isLeft || isOdd){
                first += d;
            }
            isLeft = !isLeft;
            d <<= 1;
            n >>= 1;
            isOdd = (n & 1) == 1;
        }
        return first;
    }

}
