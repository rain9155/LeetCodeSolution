package medium.leetcode153;

/**
 * 寻找旋转排序数组中的最小值：
 * 假设按照升序排序的数组在预先未知的某个点上进行了旋转，例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]。
 * 请找出其中最小的元素。
 * 
 * 你可以假设数组中不存在重复元素。
 * 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
 * 
 * 示例 1：
 * 输入：nums = [3,4,5,1,2]
 * 输出：1
 * 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
 * 
 * 示例 2：
 * 输入：nums = [4,5,6,7,0,1,2]
 * 输出：0
 * 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。
 * 
 * 示例 3：
 * 输入：nums = [11,13,15,17]
 * 输出：11
 * 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
 */
public class Solution {

    boolean isValid = false;

    /**
     * 二分查找：
     * 把数组旋转后，数组被分为两段，第一段子数组的每一个元素都大于第二段的子数组的任何元素
     * 1、我们使用两个指针p1，p2，p1指向第一段子数组的第一个元素，p2指向第二段子数组的最后一个元素
     * 2、取数组中值，当中值比p1指向的元素大时，说明断层点在中值的后面，这时把p1指向中值
     *               当中值比p2指向的元素小时，说明断层点在中值的前面，这时把p2指向中值
     * 3、不断缩小p1和p2，直到p1和p2相邻一个元素，这时p2指向的元素就是断层点，断层点就是最小的元素
     */
    public int findMin(int[] nums) {
        if(nums == null || nums.length == 0){
            isValid = true;
            return -1;
        }
        int p1 = 0, p2 = nums.length - 1;
        //特殊情况：如果整个数组都是有序的，或者这个数组只有一个元素，第一个元素就是最小元素
        if(nums[p2] >= nums[p1]){
            return nums[p1];
        }
        //进行二分查找，不断缩小p1和p2，直到p1和p2相邻，这时p2指向的元素就是断层点，断层点就是最小的元素
        while(p1 < p2){
            if(p2 - p1 == 1){
                break;
            }
            int mid = p1 + ((p2 - p1) >> 1);
            if(nums[mid] > nums[p1]){
                p1 = mid;
            }else if(nums[mid] < nums[p1]){
                p2 = mid;
            }
        }
        return nums[p2];
    }

}
